#include <typeinfo>
#include <sstream>
#ifdef __GNUG__
  #include <cxxabi.h>
  #include <cstdlib>
#endif

#include <pybind11/pybind11.h>
#include <pybind11/functional.h>
#include <pybind11/operators.h>
#include <pybind11/stl.h>

#include <cxbind/cxbind.h>
#include <crunge/wgpu/pywgpu.h>
#include <crunge/wgpu/crunge-wgpu.h>
#include <crunge/wgpu/conversions.h>

inline std::string demangle_type_name(const char* name) {
#ifdef __GNUG__
    int status = 0;
    char* dem = abi::__cxa_demangle(name, nullptr, nullptr, &status);
    std::string out = (status == 0 && dem) ? dem : name;
    std::free(dem);
    return out;
#else
    return name;
#endif
}

inline std::string py_type_qualname(py::handle h) {
    if (h.is_none()) return "None";
    py::object t = py::type::of(h);
    std::string mod = py::str(t.attr("__module__"));
    std::string name = py::str(t.attr("__qualname__"));
    return mod + "." + name;
}

struct LinearAlloc {
    uint8_t* base = nullptr;
    size_t cap = 0, off = 0;

    explicit LinearAlloc(size_t capacity = 64 * 1024) {
        base = (uint8_t*)std::malloc(capacity);
        if (!base) throw std::bad_alloc();
        cap = capacity;
    }
    ~LinearAlloc() { std::free(base); }

    void* alloc(size_t n, size_t align) {
        size_t p = (off + (align - 1)) & ~(align - 1);
        if (p + n > cap) throw std::runtime_error("LinearAlloc overflow");
        off = p + n;
        return base + p;
    }

    template<class T>
    T* alloc_array(size_t count) {
        return reinterpret_cast<T*>(alloc(sizeof(T) * count, alignof(T)));
    }

    template<class T>
    T* make() {
        void* p = alloc(sizeof(T), alignof(T));
        return new (p) T{}; // value-init
    }

    template<class T>
    T* make_array(size_t count) {
        T* p = alloc_array<T>(count);
        for (size_t i = 0; i < count; ++i) {
            new (&p[i]) T{}; // value-init each element
        }
        return p;
    }

    const char* copy_cstr(const std::string& s) {
        char* p = (char*)alloc(s.size() + 1, alignof(char));
        std::memcpy(p, s.c_str(), s.size() + 1);
        return p;
    }
};

struct BuildCtx {
    LinearAlloc& la;
    //const ChainRegistry* chains = nullptr; // optional; nullptr if you don't support nextInChain yet
};

// Fallback: if no overload exists for T, this will be selected.
template<class T>
inline void fill(T&, py::handle h, BuildCtx) {
    std::ostringstream oss;
    oss << "No generated fill(T&, py::handle, BuildCtx) overload for C++ type '"
        << demangle_type_name(typeid(T).name())
        << "'. Python value type was '" << py_type_qualname(h) << "'.";
    throw std::runtime_error(oss.str());
}

template <class T>
struct Builder {
    BuildCtx ctx;

    explicit Builder(BuildCtx c) : ctx(c) {}

    // Allocate one T and fill it.
    T* build(py::handle dc) {
        if (dc.is_none()) return nullptr;
        auto* p = ctx.la.make<T>();
        fill(*p, dc);
        return p;
    }

    // Allocate N Ts and fill each element.
    T* build_array(py::handle seq_h, uint32_t* outCount) {
        if (seq_h.is_none()) {
            *outCount = 0;
            return nullptr;
        }
        py::sequence seq = seq_h.cast<py::sequence>();
        *outCount = static_cast<uint32_t>(seq.size());
        if (*outCount == 0) return nullptr;

        T* arr = ctx.la.make_array<T>(*outCount);
        for (uint32_t i = 0; i < *outCount; ++i) {
            fill(arr[i], seq[i]);
        }
        return arr;
    }

    void fill(T& out, py::handle h) {
        using ::fill;
        fill(out, h, ctx);
    }

    // Common helpers
    const char* str_or_null(py::handle h) {
        if (h.is_none()) return nullptr;
        return ctx.la.copy_cstr(std::string(py::str(h)));
    }

    template <class H>
    H handle(py::handle h) { return h.cast<H>(); }

    template <class U>
    U* optional_ptr(py::handle h) {
        if (h.is_none()) return nullptr;
        return Builder<U>(ctx).build(h);
    }
};

template <class DstEnum, class SrcEnum>
constexpr DstEnum enum_cast(SrcEnum v) {
    using U = std::underlying_type_t<SrcEnum>;
    return static_cast<DstEnum>(static_cast<U>(v));
}

namespace py = pybind11;

using namespace pywgpu;

ChainedStruct* build_chained_struct(py::handle h, BuildCtx ctx);

{{ prologue }}

void init_wgpu_py_auto(py::module &m, Registry &registry) {
{{ py_code }}
}

{{ epilogue }}