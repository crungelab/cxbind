#include <pybind11/pybind11.h>
#include <pybind11/functional.h>
#include <pybind11/operators.h>
#include <pybind11/stl.h>

#include <cxbind/cxbind.h>
#include <crunge/wgpu/pywgpu.h>
#include <crunge/wgpu/crunge-wgpu.h>
#include <crunge/wgpu/conversions.h>

struct LinearAlloc {
    uint8_t* base = nullptr;
    size_t cap = 0, off = 0;

    explicit LinearAlloc(size_t capacity = 64 * 1024) {
        base = (uint8_t*)std::malloc(capacity);
        if (!base) throw std::bad_alloc();
        cap = capacity;
    }
    ~LinearAlloc() { std::free(base); }

    void* alloc(size_t n, size_t align) {
        size_t p = (off + (align - 1)) & ~(align - 1);
        if (p + n > cap) throw std::runtime_error("LinearAlloc overflow");
        off = p + n;
        return base + p;
    }

    template<class T>
    T* alloc_array(size_t count) {
        return reinterpret_cast<T*>(alloc(sizeof(T) * count, alignof(T)));
    }

    template<class T>
    T* make() {
        void* p = alloc(sizeof(T), alignof(T));
        return new (p) T{}; // value-init
    }

    const char* copy_cstr(const std::string& s) {
        char* p = (char*)alloc(s.size() + 1, alignof(char));
        std::memcpy(p, s.c_str(), s.size() + 1);
        return p;
    }
};

namespace py = pybind11;

using namespace pywgpu;

{{ prologue }}

void init_wgpu_pb_auto(py::module &m, Registry &registry) {
{{ py_code }}
}
